import { ɵɵdefineInjectable, Injectable, EventEmitter, Directive, ElementRef, Renderer2, Input, Output, HostListener, Component, ViewEncapsulation, ContentChild, TemplateRef, ViewChild, HostBinding, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import * as dragulaNamespace from '@swimlane/dragula';

// see https://github.com/dherges/ng-packagr/issues/217
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function ContainerComponent_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "ngx-dnd-item", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("model", item_r3)("dropZone", ctx_r2.dropZone)("dropZones", ctx_r2.dropZones)("copy", ctx_r2.copy)("moves", ctx_r2.moves)("removeOnSpill", ctx_r2.removeOnSpill)("droppableItemClass", ctx_r2.droppableItemClass);
} }
function ContainerComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ContainerComponent_ng_container_1_ng_container_1_Template, 2, 7, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.model);
} }
function ContainerComponent_ng_content_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "!model"]);
} }
const _c0 = function (a0) { return { "gu-empty": a0 }; };
const _c1 = ["*"];
function ItemComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "ngx-dnd-container", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("model", ctx_r0.model)("template", ctx_r0.container.template)("dropZone", ctx_r0.dropZone)("dropZones", ctx_r0.dropZones)("removeOnSpill", ctx_r0.removeOnSpill)("droppableItemClass", ctx_r0.droppableItemClass)("copy", ctx_r0.copy);
} }
function ItemComponent_ng_container_2_1_ng_template_0_Template(rf, ctx) { }
function ItemComponent_ng_container_2_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 5);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.container.template)("ngTemplateOutletContext", ctx_r4.data);
} }
function ItemComponent_ng_container_2_ng_container_2_ngx_dnd_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngx-dnd-container", 3);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("model", ctx_r7.model.children)("template", ctx_r7.container.template)("dropZone", ctx_r7.dropZone)("dropZones", ctx_r7.dropZones)("removeOnSpill", ctx_r7.removeOnSpill)("droppableItemClass", ctx_r7.droppableItemClass)("copy", ctx_r7.copy);
} }
function ItemComponent_ng_container_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 6);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, ItemComponent_ng_container_2_ng_container_2_ngx_dnd_container_3_Template, 1, 7, "ngx-dnd-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.model.label, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.model.children);
} }
function ItemComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_container_2_1_Template, 1, 2, undefined, 4);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_container_2_ng_container_2_Template, 4, 2, "ng-container", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.container.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.container.template);
} }
function ItemComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function ItemComponent_ng_container_4_1_ng_template_0_Template(rf, ctx) { }
function ItemComponent_ng_container_4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_container_4_1_ng_template_0_Template, 0, 0, "ng-template", 5);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r8.container.template)("ngTemplateOutletContext", ctx_r8.data);
} }
function ItemComponent_ng_container_4_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r9.model, " ");
} }
function ItemComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_container_4_1_Template, 1, 2, undefined, 4);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_container_4_div_2_Template, 2, 1, "div", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.container.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.container.template);
} }
const dragula = dragulaNamespace;
/**
 * Central service that handles all events
 *
 * @export
 */
class DrakeStoreService {
    constructor() {
        this.droppableMap = new WeakMap();
        this.draggableMap = new WeakMap();
        this.dragulaOptions = this.createDrakeOptions();
        this.drake = dragula([], this.dragulaOptions);
        this.registerEvents();
    }
    register(droppable) {
        this.droppableMap.set(droppable.container, droppable);
        this.drake.containers.push(droppable.container);
    }
    remove(droppable) {
        this.droppableMap.delete(droppable.container);
        const idx = this.drake.containers.indexOf(droppable.container);
        if (idx > -1) {
            this.drake.containers.splice(idx, 1);
        }
    }
    registerDraggable(draggable) {
        this.draggableMap.set(draggable.element, draggable);
    }
    removeDraggable(draggable) {
        this.draggableMap.delete(draggable.element);
    }
    createDrakeOptions() {
        const accepts = (el, target /*, source: any, sibling: any */) => {
            if (el.contains(target)) {
                return false;
            }
            const elementComponent = this.draggableMap.get(el);
            const targetComponent = this.droppableMap.get(target);
            if (elementComponent && targetComponent) {
                return elementComponent.dropZones.includes(targetComponent.dropZone);
            }
            return true;
        };
        const copy = (_, source) => {
            const sourceComponent = this.droppableMap.get(source);
            if (sourceComponent) {
                return sourceComponent.copy;
            }
            return false;
        };
        const moves = (el, source, handle, sibling) => {
            const elementComponent = this.draggableMap.get(el);
            if (elementComponent) {
                return elementComponent.moves(source, handle, sibling);
            }
            return true;
        };
        const direction = (el, target, source) => {
            const targetComponent = this.droppableMap.get(target);
            return targetComponent.direction || 'vertical';
        };
        return { accepts, copy, moves, revertOnSpill: true, direction };
    }
    registerEvents() {
        let dragElm;
        let draggedItem;
        this.drake.on('drag', (el, source) => {
            draggedItem = undefined;
            dragElm = el;
            if (!el || !source) {
                return;
            }
            if (this.draggableMap.has(el)) {
                const elementComponent = this.draggableMap.get(el);
                draggedItem = elementComponent.model;
                elementComponent.drag.emit({
                    type: 'drag',
                    el,
                    source,
                    value: draggedItem
                });
            }
            if (this.droppableMap.has(source)) {
                const sourceComponent = this.droppableMap.get(source);
                this.dragulaOptions.removeOnSpill = sourceComponent.removeOnSpill;
                sourceComponent.drag.emit({
                    type: 'drag',
                    el,
                    source,
                    sourceComponent,
                    value: draggedItem
                });
            }
        });
        this.drake.on('drop', (el, target, source) => {
            const targetComponent = this.droppableMap.get(target);
            if (!targetComponent) {
                // not a target, abort
                return;
            }
            let dropElmModel = draggedItem;
            const dropIndex = Array.prototype.indexOf.call(target.children, el);
            if (dropIndex < 0) {
                // dropIndex is bad... cancel
                this.drake.cancel(true);
                return;
            }
            const sourceComponent = this.droppableMap.get(source);
            if (sourceComponent) {
                const sourceModel = sourceComponent.model;
                const targetModel = targetComponent.model;
                const hasDragModel = !!(sourceModel && draggedItem);
                const dragIndex = hasDragModel ? sourceModel.indexOf(draggedItem) : -1;
                if (hasDragModel && dragIndex < 0) {
                    // dragIndex is bad... cancel
                    this.drake.cancel(true);
                    return;
                }
                if (targetModel) {
                    const reorder = dragIndex > -1 && sourceModel && target === source;
                    const copy = !sourceModel || dragElm !== el;
                    if (reorder) {
                        sourceModel.splice(dropIndex, 0, sourceModel.splice(dragIndex, 1)[0]);
                    }
                    else {
                        if (el.parentNode === target) {
                            target.removeChild(el);
                        }
                        if (copy) {
                            dropElmModel = JSON.parse(JSON.stringify(dropElmModel));
                        }
                        else {
                            if (el.parentNode !== source) {
                                // add element back, let angular remove it
                                this.drake.cancel(true);
                            }
                            sourceModel.splice(dragIndex, 1);
                        }
                        targetModel.splice(dropIndex, 0, dropElmModel);
                    }
                }
            }
            targetComponent.drop.emit({
                type: 'drop',
                el,
                source,
                value: dropElmModel,
                dropIndex
            });
        });
        this.drake.on('remove', (el, container, source) => {
            if (this.droppableMap.has(source)) {
                const sourceComponent = this.droppableMap.get(source);
                const sourceModel = sourceComponent.model;
                const dragIndex = draggedItem && sourceModel ? sourceModel.indexOf(draggedItem) : -1;
                if (dragIndex > -1) {
                    if (el.parentNode !== source) {
                        // add element back, let angular remove it
                        source.appendChild(el);
                    }
                    sourceModel.splice(dragIndex, 1);
                }
                sourceComponent.remove.emit({
                    type: 'remove',
                    el,
                    container,
                    source,
                    value: draggedItem
                });
            }
        });
        this.drake.on('cancel', (el, container, source) => {
            if (this.droppableMap.has(container)) {
                const containerComponent = this.droppableMap.get(container);
                containerComponent.cancel.emit({
                    type: 'cancel',
                    el,
                    container,
                    source,
                    value: draggedItem
                });
            }
        });
        this.drake.on('over', (el, container, source) => {
            if (this.droppableMap.has(container)) {
                const containerComponent = this.droppableMap.get(container);
                containerComponent.over.emit({
                    type: 'over',
                    el,
                    container,
                    source,
                    value: draggedItem
                });
            }
        });
        this.drake.on('out', (el, container, source) => {
            if (this.droppableMap.has(container)) {
                const containerComponent = this.droppableMap.get(container);
                containerComponent.out.emit({
                    type: 'out',
                    el,
                    container,
                    source,
                    value: draggedItem
                });
            }
        });
    }
}
DrakeStoreService.ɵfac = function DrakeStoreService_Factory(t) { return new (t || DrakeStoreService)(); };
DrakeStoreService.ɵprov = ɵɵdefineInjectable({ factory: function DrakeStoreService_Factory() { return new DrakeStoreService(); }, token: DrakeStoreService, providedIn: "root" });
DrakeStoreService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrakeStoreService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

let i = 10000;
function getNextId() {
    return i++;
}
/**
 * Makes the container droppable and children draggable.
 *
 * @export
 */
class DroppableDirective {
    constructor(el, renderer, drakesService) {
        this.el = el;
        this.renderer = renderer;
        this.drakesService = drakesService;
        this.copy = false;
        this.removeOnSpill = false;
        this.direction = 'vertical';
        this.drop = new EventEmitter();
        this.drag = new EventEmitter();
        this.over = new EventEmitter();
        this.out = new EventEmitter();
        this.remove = new EventEmitter();
        this.cancel = new EventEmitter();
    }
    get container() {
        return this.el.nativeElement;
    }
    get dropZone() {
        return this._dropZone || this.ngxDroppable || this.defaultZone;
    }
    set dropZone(val) {
        this._dropZone = val;
    }
    ngOnInit() {
        this.defaultZone = `@@DefaultDropZone-${getNextId()}@@`;
        this.drakesService.register(this);
    }
    ngAfterViewInit() {
        this.over.subscribe(() => {
            this.renderer.addClass(this.container, 'gu-over');
        });
        this.out.subscribe(() => {
            this.renderer.removeClass(this.container, 'gu-over');
        });
    }
    ngOnDestroy() {
        this.drakesService.remove(this);
    }
}
DroppableDirective.ɵfac = function DroppableDirective_Factory(t) { return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DrakeStoreService)); };
DroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DroppableDirective, selectors: [["", "ngxDroppable", ""]], inputs: { copy: "copy", removeOnSpill: "removeOnSpill", direction: "direction", dropZone: "dropZone", model: "model", ngxDroppable: "ngxDroppable" }, outputs: { drop: "drop", drag: "drag", over: "over", out: "out", remove: "remove", cancel: "cancel" } });
DroppableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DrakeStoreService }
];
DroppableDirective.propDecorators = {
    model: [{ type: Input }],
    copy: [{ type: Input }],
    removeOnSpill: [{ type: Input }],
    ngxDroppable: [{ type: Input }],
    direction: [{ type: Input }],
    drop: [{ type: Output }],
    drag: [{ type: Output }],
    over: [{ type: Output }],
    out: [{ type: Output }],
    remove: [{ type: Output }],
    cancel: [{ type: Output }],
    dropZone: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{
        type: Directive,
        args: [{ selector: '[ngxDroppable]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: DrakeStoreService }]; }, { copy: [{
            type: Input
        }], removeOnSpill: [{
            type: Input
        }], direction: [{
            type: Input
        }], drop: [{
            type: Output
        }], drag: [{
            type: Output
        }], over: [{
            type: Output
        }], out: [{
            type: Output
        }], remove: [{
            type: Output
        }], cancel: [{
            type: Output
        }], dropZone: [{
            type: Input
        }], model: [{
            type: Input
        }], ngxDroppable: [{
            type: Input
        }] }); })();

/**
 * Adds properties and events to draggable elements
 *
 * @export
 */
class DraggableDirective {
    constructor(el, drakesService, droppableDirective) {
        this.el = el;
        this.drakesService = drakesService;
        this.droppableDirective = droppableDirective;
        this._moves = true;
        /*
        ContentChildren doesn't get children created with NgTemplateOutlet
        See https://github.com/angular/angular/issues/14842
        Implemented via updateElements method
      
        @ContentChildren(DragHandleDirective, {descendants: true})
        handlesList: QueryList<DragHandleDirective>; */
        this.handles = [];
        this.drag = new EventEmitter();
        this.dragDelay = 200; // milliseconds
        this.dragDelayed = true;
    }
    get dropZones() {
        return this._dropZones || this.ngxDraggable || this._parentDropzones;
    }
    set dropZones(val) {
        this._dropZones = val;
    }
    get hasHandle() {
        return !!this.handles.length;
    }
    get element() {
        return this.el.nativeElement;
    }
    // From: https://github.com/bevacqua/dragula/issues/289#issuecomment-277143172
    onMove(e) {
        if (!this._moves || this.dragDelayed) {
            e.stopPropagation();
            clearTimeout(this.touchTimeout);
        }
    }
    onDown() {
        if (this._moves) {
            this.touchTimeout = setTimeout(() => {
                this.dragDelayed = false;
            }, this.dragDelay);
        }
    }
    onUp() {
        if (this._moves) {
            clearTimeout(this.touchTimeout);
            this.dragDelayed = true;
        }
    }
    ngOnInit() {
        this.update();
    }
    update() {
        this._parentDropzones = [this.droppableDirective.dropZone];
        this.drakesService.registerDraggable(this);
        this.updateElements();
    }
    ngOnDestroy() {
        this.drakesService.removeDraggable(this);
    }
    updateElements() {
        const nativeElement = this.el.nativeElement;
        const handles = nativeElement.querySelectorAll('[ngxdraghandle]');
        this.handles = Array.from(handles).filter((h) => findFirstDraggableParent(h) === nativeElement);
        function findFirstDraggableParent(c) {
            while (c.parentNode) {
                c = c.parentNode;
                if (c.hasAttribute && c.hasAttribute('ngxdraggable')) {
                    return c;
                }
            }
        }
    }
    canMove(source, handle, sibling) {
        if (typeof this._moves === 'boolean')
            return this._moves;
        if (typeof this._moves === 'function')
            return this._moves(this.model, source, handle, sibling);
        return true;
    }
    moves(source, handle, sibling) {
        if (!this.canMove(source, handle, sibling))
            return false;
        return this.hasHandle ? this.handles.some(h => handelFor(handle, h)) : true;
        function handelFor(c, p) {
            if (c === p)
                return true;
            while ((c = c.parentNode) && c !== p)
                ; // tslint:disable-line
            return !!c;
        }
    }
    ngDoCheck() {
        this.updateElements();
    }
}
DraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DrakeStoreService), ɵngcc0.ɵɵdirectiveInject(DroppableDirective)); };
DraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DraggableDirective, selectors: [["", "ngxDraggable", ""]], hostBindings: function DraggableDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("touchmove", function DraggableDirective_touchmove_HostBindingHandler($event) { return ctx.onMove($event); })("touchstart", function DraggableDirective_touchstart_HostBindingHandler() { return ctx.onDown(); })("touchend", function DraggableDirective_touchend_HostBindingHandler() { return ctx.onUp(); });
    } }, inputs: { _moves: ["moves", "_moves"], dropZones: "dropZones", ngxDraggable: "ngxDraggable", model: "model" }, outputs: { drag: "drag" } });
DraggableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DrakeStoreService },
    { type: DroppableDirective }
];
DraggableDirective.propDecorators = {
    ngxDraggable: [{ type: Input }],
    model: [{ type: Input }],
    dropZones: [{ type: Input }],
    _moves: [{ type: Input, args: ['moves',] }],
    drag: [{ type: Output }],
    onMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
    onDown: [{ type: HostListener, args: ['touchstart',] }],
    onUp: [{ type: HostListener, args: ['touchend',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{
        type: Directive,
        args: [{ selector: '[ngxDraggable]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DrakeStoreService }, { type: DroppableDirective }]; }, { _moves: [{
            type: Input,
            args: ['moves']
        }], drag: [{
            type: Output
        }], dropZones: [{
            type: Input
        }], 
    // From: https://github.com/bevacqua/dragula/issues/289#issuecomment-277143172
    onMove: [{
            type: HostListener,
            args: ['touchmove', ['$event']]
        }], onDown: [{
            type: HostListener,
            args: ['touchstart']
        }], onUp: [{
            type: HostListener,
            args: ['touchend']
        }], ngxDraggable: [{
            type: Input
        }], model: [{
            type: Input
        }] }); })();

/**
 * Adds properties and events to drag handle elements
 *
 * @export
 */
class DragHandleDirective {
}
DragHandleDirective.ɵfac = function DragHandleDirective_Factory(t) { return new (t || DragHandleDirective)(); };
DragHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DragHandleDirective, selectors: [["", "ngxDragHandle", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragHandleDirective, [{
        type: Directive,
        args: [{ selector: '[ngxDragHandle]' }]
    }], null, null); })();

let i$1 = 0;
function getNextId$1() {
    return i$1++;
}
/**
 * Component that allows nested ngxDroppable and ngxDraggables
 *
 * @export
 */
class ContainerComponent {
    constructor() {
        this.copy = false;
        this.removeOnSpill = false;
        this.dropZone = `@@DefaultDropZone-${getNextId$1()}@@`;
        this.drop = new EventEmitter();
        this.drag = new EventEmitter();
        this.over = new EventEmitter();
        this.out = new EventEmitter();
        this.remove = new EventEmitter();
        this.cancel = new EventEmitter();
    }
    get dropZones() {
        return this._dropZones || this._defaultZones;
    }
    set dropZones(val) {
        this._dropZones = val;
    }
    // @Input() classes: any = {};
    // @Input() dragulaOptions: any;
    set templateInput(template) {
        this.template = template;
    }
    set templateChild(template) {
        this.template = template;
    }
    ngOnInit() {
        this._defaultZones = [this.dropZone];
    }
    ngAfterViewInit() {
        this.droppable.drag.subscribe((v) => this.drag.emit(v));
        this.droppable.drop.subscribe((v) => this.drop.emit(v));
        this.droppable.over.subscribe((v) => this.over.emit(v));
        this.droppable.out.subscribe((v) => this.out.emit(v));
        this.droppable.remove.subscribe((v) => this.remove.emit(v));
        this.droppable.cancel.subscribe((v) => this.cancel.emit(v));
    }
}
ContainerComponent.ɵfac = function ContainerComponent_Factory(t) { return new (t || ContainerComponent)(); };
ContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ContainerComponent, selectors: [["ngx-dnd-container"]], contentQueries: function ContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, TemplateRef, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateChild = _t.first);
    } }, viewQuery: function ContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(DroppableDirective, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.droppable = _t.first);
    } }, inputs: { copy: "copy", removeOnSpill: "removeOnSpill", dropZone: "dropZone", dropZones: "dropZones", templateInput: ["template", "templateInput"], model: "model", droppableItemClass: "droppableItemClass", moves: "moves" }, outputs: { drop: "drop", drag: "drag", over: "over", out: "out", remove: "remove", cancel: "cancel" }, ngContentSelectors: _c1, decls: 3, vars: 9, consts: [["ngxDroppable", "", 1, "ngx-dnd-container", 3, "dropZone", "model", "copy", "ngClass", "removeOnSpill"], [4, "ngIf"], [4, "ngFor", "ngForOf"], ["ngxDraggable", "", 3, "model", "dropZone", "dropZones", "copy", "moves", "removeOnSpill", "droppableItemClass"]], template: function ContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ContainerComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, ContainerComponent_ng_content_2_Template, 1, 0, "ng-content", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("dropZone", ctx.dropZone)("model", ctx.model)("copy", ctx.copy)("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c0, !(ctx.model == null ? null : ctx.model.length)))("removeOnSpill", ctx.removeOnSpill);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.model);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.model);
    } }, directives: function () { return [DroppableDirective, ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgForOf, ItemComponent, DraggableDirective]; }, styles: [".ngx-dnd-container{background-color:hsla(0,0%,100%,.2);border:2px solid red;margin:10px;padding:10px}.ngx-dnd-container.gu-empty{border:2px dotted red}.ngx-dnd-container:nth-child(odd){background-color:rgba(0,0,0,.2)}.ngx-dnd-container .ex-moved{background-color:#e74c3c}.ngx-dnd-container .ex-over{background-color:hsla(0,0%,100%,.3)}.ngx-dnd-container .handle{background-color:rgba(0,0,0,.4);cursor:move;margin-right:5px;padding:0 5px}.no-select{-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.clearfix:after{clear:both;content:\" \";display:block;height:0}"], encapsulation: 2 });
ContainerComponent.propDecorators = {
    model: [{ type: Input }],
    copy: [{ type: Input }],
    removeOnSpill: [{ type: Input }],
    droppableItemClass: [{ type: Input }],
    dropZone: [{ type: Input }],
    dropZones: [{ type: Input }],
    moves: [{ type: Input }],
    templateInput: [{ type: Input, args: ['template',] }],
    templateChild: [{ type: ContentChild, args: [TemplateRef, { static: true },] }],
    droppable: [{ type: ViewChild, args: [DroppableDirective, { static: true },] }],
    drop: [{ type: Output }],
    drag: [{ type: Output }],
    over: [{ type: Output }],
    out: [{ type: Output }],
    remove: [{ type: Output }],
    cancel: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContainerComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-dnd-container',
                template: "<div\n  ngxDroppable\n  [dropZone]=\"dropZone\"\n  [model]=\"model\"\n  [copy]=\"copy\"\n  [ngClass]=\"{ 'gu-empty': !model?.length }\"\n  [removeOnSpill]=\"removeOnSpill\"\n  class='ngx-dnd-container'>\n  <ng-container *ngIf=\"model\">\n    <ng-container *ngFor=\"let item of model\">\n      <ngx-dnd-item\n        ngxDraggable\n        [model]=\"item\"\n        [dropZone]=\"dropZone\"\n        [dropZones]=\"dropZones\"\n        [copy]=\"copy\"\n        [moves]=\"moves\"\n        [removeOnSpill]=\"removeOnSpill\"\n        [droppableItemClass]=\"droppableItemClass\">\n      </ngx-dnd-item>\n    </ng-container>\n  </ng-container>\n  <ng-content *ngIf=\"!model\"></ng-content>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-dnd-container{background-color:hsla(0,0%,100%,.2);border:2px solid red;margin:10px;padding:10px}.ngx-dnd-container.gu-empty{border:2px dotted red}.ngx-dnd-container:nth-child(odd){background-color:rgba(0,0,0,.2)}.ngx-dnd-container .ex-moved{background-color:#e74c3c}.ngx-dnd-container .ex-over{background-color:hsla(0,0%,100%,.3)}.ngx-dnd-container .handle{background-color:rgba(0,0,0,.4);cursor:move;margin-right:5px;padding:0 5px}.no-select{-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.clearfix:after{clear:both;content:\" \";display:block;height:0}"]
            }]
    }], function () { return []; }, { copy: [{
            type: Input
        }], removeOnSpill: [{
            type: Input
        }], dropZone: [{
            type: Input
        }], drop: [{
            type: Output
        }], drag: [{
            type: Output
        }], over: [{
            type: Output
        }], out: [{
            type: Output
        }], remove: [{
            type: Output
        }], cancel: [{
            type: Output
        }], dropZones: [{
            type: Input
        }], templateInput: [{
            type: Input,
            args: ['template']
        }], templateChild: [{
            type: ContentChild,
            args: [TemplateRef, { static: true }]
        }], model: [{
            type: Input
        }], droppableItemClass: [{
            type: Input
        }], moves: [{
            type: Input
        }], droppable: [{
            type: ViewChild,
            args: [DroppableDirective, { static: true }]
        }] }); })();

/**
 * Component that allows nested ngxDroppable and ngxDraggables
 * Should only be use inside a ngx-dnd-container
 * Outside a ngx-dnd-container use ngxDroppable
 *
 * @export
 */
class ItemComponent {
    constructor(container, draggableDirective) {
        this.container = container;
        this.draggableDirective = draggableDirective;
        this._copy = false;
        this._removeOnSpill = false;
    }
    get dropZone() {
        return this._dropZone || this.container.dropZone;
    }
    set dropZone(val) {
        this._dropZone = val;
    }
    get dropZones() {
        return this._dropZones || this.container.dropZones;
    }
    set dropZones(val) {
        this._dropZones = val;
    }
    get droppableItemClass() {
        return this._droppableItemClass || this.container.droppableItemClass;
    }
    set droppableItemClass(val) {
        this._droppableItemClass = val;
    }
    get removeOnSpill() {
        return typeof this._removeOnSpill === 'boolean' ? this._removeOnSpill : this.container.removeOnSpill;
    }
    set removeOnSpill(val) {
        this._removeOnSpill = val;
    }
    get copy() {
        return typeof this._copy === 'boolean' ? this._copy : this.container.copy;
    }
    set copy(val) {
        this._copy = val;
    }
    get hasHandle() {
        return this.draggableDirective.hasHandle;
    }
    get moveDisabled() {
        return !this.draggableDirective.canMove();
    }
    get classString() {
        const itemClass = typeof this.droppableItemClass === 'function' ? this.droppableItemClass(this.model) : this.droppableItemClass;
        const classes = ['ngx-dnd-item', itemClass || ''];
        if (this.moveDisabled) {
            classes.push('move-disabled');
        }
        if (this.hasHandle) {
            classes.push('has-handle');
        }
        return classes.join(' ');
    }
    get type() {
        if (Array.isArray(this.model)) {
            return 'array';
        }
        return typeof this.model;
    }
    ngOnInit() {
        this.data = {
            model: this.model,
            type: this.type,
            dropZone: this.dropZone,
            template: this.container.template
        };
    }
}
ItemComponent.ɵfac = function ItemComponent_Factory(t) { return new (t || ItemComponent)(ɵngcc0.ɵɵdirectiveInject(ContainerComponent), ɵngcc0.ɵɵdirectiveInject(DraggableDirective)); };
ItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ItemComponent, selectors: [["ngx-dnd-item"]], hostVars: 2, hostBindings: function ItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.classString);
    } }, inputs: { dropZone: "dropZone", dropZones: "dropZones", droppableItemClass: "droppableItemClass", removeOnSpill: "removeOnSpill", copy: "copy", model: "model" }, decls: 5, vars: 4, consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "model", "template", "dropZone", "dropZones", "removeOnSpill", "droppableItemClass", "copy"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "ngx-dnd-content"], [3, "model", "template", "dropZone", "dropZones", "removeOnSpill", "droppableItemClass", "copy", 4, "ngIf"], ["class", "ngx-dnd-content", 4, "ngIf"]], template: function ItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_container_1_Template, 2, 7, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(3, ItemComponent_ng_container_3_Template, 1, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(4, ItemComponent_ng_container_4_Template, 3, 2, "ng-container", 2);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.type);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "array");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "object");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "undefined");
    } }, directives: [ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, ɵngcc1.NgSwitchDefault, ContainerComponent, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".ngx-dnd-box,.ngx-dnd-item{background-color:rgba(0,0,0,.2);border:1px solid #add8e6;display:block;margin:10px;padding:10px;transition:opacity .4s ease-in-out}.ngx-dnd-box.has-handle [ngxdraghandle],.ngx-dnd-box.has-handle [ngxDragHandle],.ngx-dnd-box:not(.has-handle):not(.move-disabled),.ngx-dnd-item.has-handle [ngxdraghandle],.ngx-dnd-item.has-handle [ngxDragHandle],.ngx-dnd-item:not(.has-handle):not(.move-disabled){cursor:move;cursor:grab;cursor:-webkit-grab}.ngx-dnd-box .ngx-dnd-content,.ngx-dnd-item .ngx-dnd-content{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none}.ngx-dnd-box:hover,.ngx-dnd-item:hover{border:1px solid #00f}.ngx-dnd-box{float:left;height:40px;line-height:20px;text-align:center;width:40px}.gu-mirror{-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";filter:alpha(opacity=80);margin:0!important;opacity:.8;position:fixed!important;z-index:9999!important}.gu-hide{display:none!important}.gu-unselectable{-moz-user-select:none!important;-ms-user-select:none!important;-webkit-user-select:none!important;user-select:none!important}.gu-transit{-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";filter:alpha(opacity=20);opacity:.2}"], encapsulation: 2 });
ItemComponent.ctorParameters = () => [
    { type: ContainerComponent },
    { type: DraggableDirective }
];
ItemComponent.propDecorators = {
    model: [{ type: Input }],
    dropZone: [{ type: Input }],
    dropZones: [{ type: Input }],
    droppableItemClass: [{ type: Input }],
    removeOnSpill: [{ type: Input }],
    copy: [{ type: Input }],
    classString: [{ type: HostBinding, args: ['class',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-dnd-item',
                template: "<ng-container [ngSwitch]=\"type\">\n\n  <ng-container *ngSwitchCase=\"'array'\">\n    <ngx-dnd-container\n      [model]=\"model\"\n      [template]=\"container.template\"\n      [dropZone]=\"dropZone\"\n      [dropZones]=\"dropZones\"\n      [removeOnSpill]=\"removeOnSpill\"\n      [droppableItemClass]=\"droppableItemClass\"\n      [copy]=\"copy\">\n    </ngx-dnd-container>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"'object'\">\n    <ng-template\n      *ngIf=\"container.template\"\n      [ngTemplateOutlet]=\"container.template\"\n      [ngTemplateOutletContext]=\"data\">\n    </ng-template>\n    <ng-container *ngIf=\"!container.template\">\n      <div\n        class=\"ngx-dnd-content\">\n        {{model.label}}\n      </div>\n      <ngx-dnd-container\n        *ngIf=\"model.children\"\n        [model]=\"model.children\"\n        [template]=\"container.template\"\n        [dropZone]=\"dropZone\"\n        [dropZones]=\"dropZones\"\n        [removeOnSpill]=\"removeOnSpill\"\n        [droppableItemClass]=\"droppableItemClass\"\n        [copy]=\"copy\">\n      </ngx-dnd-container>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"'undefined'\">\n  </ng-container>\n\n  <ng-container *ngSwitchDefault>\n    <ng-template\n      *ngIf=\"container.template\"\n      [ngTemplateOutlet]=\"container.template\"\n      [ngTemplateOutletContext]=\"data\">\n    </ng-template>\n    <div\n      *ngIf=\"!container.template\"\n      class=\"ngx-dnd-content\">\n      {{model}}\n    </div>\n  </ng-container>\n\n</ng-container>\n\n\n\n\n\n\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-dnd-box,.ngx-dnd-item{background-color:rgba(0,0,0,.2);border:1px solid #add8e6;display:block;margin:10px;padding:10px;transition:opacity .4s ease-in-out}.ngx-dnd-box.has-handle [ngxdraghandle],.ngx-dnd-box.has-handle [ngxDragHandle],.ngx-dnd-box:not(.has-handle):not(.move-disabled),.ngx-dnd-item.has-handle [ngxdraghandle],.ngx-dnd-item.has-handle [ngxDragHandle],.ngx-dnd-item:not(.has-handle):not(.move-disabled){cursor:move;cursor:grab;cursor:-webkit-grab}.ngx-dnd-box .ngx-dnd-content,.ngx-dnd-item .ngx-dnd-content{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none}.ngx-dnd-box:hover,.ngx-dnd-item:hover{border:1px solid #00f}.ngx-dnd-box{float:left;height:40px;line-height:20px;text-align:center;width:40px}.gu-mirror{-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";filter:alpha(opacity=80);margin:0!important;opacity:.8;position:fixed!important;z-index:9999!important}.gu-hide{display:none!important}.gu-unselectable{-moz-user-select:none!important;-ms-user-select:none!important;-webkit-user-select:none!important;user-select:none!important}.gu-transit{-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";filter:alpha(opacity=20);opacity:.2}"]
            }]
    }], function () { return [{ type: ContainerComponent }, { type: DraggableDirective }]; }, { dropZone: [{
            type: Input
        }], dropZones: [{
            type: Input
        }], droppableItemClass: [{
            type: Input
        }], removeOnSpill: [{
            type: Input
        }], copy: [{
            type: Input
        }], classString: [{
            type: HostBinding,
            args: ['class']
        }], model: [{
            type: Input
        }] }); })();

const components = [ContainerComponent, ItemComponent];
const directives = [DraggableDirective, DroppableDirective, DragHandleDirective];
class NgxDnDModule {
    static forRoot() {
        return {
            ngModule: NgxDnDModule,
            providers: [DrakeStoreService]
        };
    }
}
NgxDnDModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxDnDModule });
NgxDnDModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxDnDModule_Factory(t) { return new (t || NgxDnDModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxDnDModule, { declarations: function () { return [ContainerComponent, ItemComponent, DraggableDirective, DroppableDirective, DragHandleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ContainerComponent, ItemComponent, DraggableDirective, DroppableDirective, DragHandleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxDnDModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [...components, ...directives],
                exports: [...components, ...directives]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ContainerComponent, DragHandleDirective, DraggableDirective, DrakeStoreService, DroppableDirective, ItemComponent, NgxDnDModule };

//# sourceMappingURL=swimlane-ngx-dnd.js.map